[
  {
    "projectId": "01f1f17b-e479-4dc0-be9b-8907bc797733",
    "testId": "213d075c-6590-4eb8-a240-90254506ffe5",
    "userId": "5408b468-b0c1-70d2-5327-b6b9f4d085bb",
    "title": "TC001-Homepage Banner Carousel Functionality",
    "description": "Verify that the dynamic banner carousel on the homepage displays featured products and promotions, auto-scrolls correctly, and user controls like next/previous buttons work as expected.",
    "code": "import asyncio\nfrom playwright import async_api\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # Check the banner carousel is visible and contains featured products and promotions\n        await page.mouse.wheel(0, window.innerHeight)\n        \n\n        # Click the next button on the carousel to verify banner changes\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/main/section/section/div/button[2]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # Click the previous button on the carousel to verify banner changes\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/main/section/section/div/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # Resize the browser window and check responsiveness\n        await page.mouse.wheel(0, window.innerHeight)\n        \n\n        # Resize the browser window and check responsiveness of the carousel layout\n        await page.goto('http://localhost:3000/', timeout=10000)\n        \n\n        await page.mouse.wheel(0, window.innerHeight)\n        \n\n        # Resize the browser window to simulate mobile view and verify carousel layout responsiveness\n        await page.goto('http://localhost:3000/', timeout=10000)\n        \n\n        await page.mouse.wheel(0, window.innerHeight)\n        \n\n        # Resize the browser window to simulate mobile view and verify carousel layout responsiveness\n        await page.goto('http://localhost:3000/', timeout=10000)\n        \n\n        await page.mouse.wheel(0, window.innerHeight)\n        \n\n        # Assert the banner carousel is visible and contains featured products and promotions\n        carousel = await page.locator('section.banner-carousel')\n        assert await carousel.is_visible(), 'Banner carousel should be visible on the homepage'\n        # Check that featured products and promotions are present in the carousel\n        carousel_items = await carousel.locator('div.carousel-item').all()\n        assert len(carousel_items) > 0, 'Carousel should contain featured products and promotions'\n        # Validate the carousel auto-scrolls to next banners at regular intervals\n        first_banner = await carousel.locator('div.carousel-item.active').nth(0).inner_text()\n        await page.wait_for_timeout(11000)  # Wait for 11 seconds to observe auto-scroll\n        second_banner = await carousel.locator('div.carousel-item.active').nth(0).inner_text()\n        assert first_banner != second_banner, 'Carousel should auto-scroll to next banner after interval'\n        # Verify the banner changes to the next item on user click\n        next_button = await page.locator('button.next').first()\n        await next_button.click()\n        next_banner = await carousel.locator('div.carousel-item.active').nth(0).inner_text()\n        assert second_banner != next_banner, 'Banner should change to next item on next button click'\n        # Verify the banner changes to the previous item on user click\n        prev_button = await page.locator('button.prev').first()\n        await prev_button.click()\n        prev_banner = await carousel.locator('div.carousel-item.active').nth(0).inner_text()\n        assert next_banner != prev_banner, 'Banner should change to previous item on prev button click'\n        # Validate carousel layout adapts correctly on mobile, tablet, and desktop views\n        # Desktop view\n        await page.set_viewport_size({'width': 1280, 'height': 800})\n        assert await carousel.is_visible(), 'Carousel should be visible in desktop view'\n        # Tablet view\n        await page.set_viewport_size({'width': 768, 'height': 1024})\n        assert await carousel.is_visible(), 'Carousel should be visible in tablet view'\n        # Mobile view\n        await page.set_viewport_size({'width': 375, 'height': 667})\n        assert await carousel.is_visible(), 'Carousel should be visible in mobile view'\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "PASSED",
    "testError": "",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/5408b468-b0c1-70d2-5327-b6b9f4d085bb/1758302187617149//tmp/test_task/result.webm",
    "created": "2025-09-19T17:03:44.102Z",
    "modified": "2025-09-19T17:16:27.872Z"
  },
  {
    "projectId": "01f1f17b-e479-4dc0-be9b-8907bc797733",
    "testId": "114cfd68-c8c4-4d77-b104-d3140f61c0a0",
    "userId": "5408b468-b0c1-70d2-5327-b6b9f4d085bb",
    "title": "TC002-Three-Level Hierarchical Product Browsing",
    "description": "Ensure that users can browse products through a three-level category hierarchy, and all category links fetch correct products.",
    "code": "import asyncio\nfrom playwright import async_api\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # Click on 'Categories' link to navigate to categories page\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/header/nav/div/div[8]/ul/li[2]/a').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # Click on 'Men Products' top-level category to reveal second-level subcategories\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/header/nav/div/div[8]/ul/li[2]/ul/li[2]/a').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        assert False, 'Test plan execution failed: generic failure assertion.'\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "Testing stopped due to critical error encountered when clicking on 'Men Products' category. The error prevents verifying the three-level category hierarchy and product listings. Issue reported for developer attention.\nBrowser Console Logs:\n[ERROR] Failed to load resource: the server responded with a status of 400 (Bad Request) (at http://localhost:3000/_next/image?url=http%3A%2F%2Flocalhost%3A5003&w=256&q=75:0:0)\n[ERROR] %o\n\n%s Error: Failed to fetch category\n    at getCategory (rsc://React/Server/C:%5CUsers%5Ckunal%5COneDrive%5CDesktop%5CWebsite%5Csample%5Cclient%5C.next%5Cserver%5Cchunks%5Cssr%5C_afb76699._.js?96:353:24)\n    at async SubCategories (rsc://React/Server/C:%5CUsers%5Ckunal%5COneDrive%5CDesktop%5CWebsite%5Csample%5Cclient%5C.next%5Cserver%5Cchunks%5Cssr%5C_afb76699._.js?97:365:39)\n    at resolveErrorDev (http://localhost:3000/_next/static/chunks/node_modules_next_dist_compiled_2ce9398a._.js:17582:48)\n    at processFullStringRow (http://localhost:3000/_next/static/chunks/node_modules_next_dist_compiled_2ce9398a._.js:17798:23)\n    at processFullBinaryRow (http://localhost:3000/_next/static/chunks/node_modules_next_dist_compiled_2ce9398a._.js:17786:9)\n    at progress (http://localhost:3000/_next/static/chunks/node_modules_next_dist_compiled_2ce9398a._.js:17932:102) The above error occurred in the <SubCategories> component. It was handled by the <ErrorBoundaryHandler> error boundary. (at http://localhost:3000/_next/static/chunks/node_modules_next_dist_client_8f19e6fb._.js:1863:54)\n[ERROR] Error page caught: Error: Failed to fetch category\n    at getCategory (rsc://React/Server/C:%5CUsers%5Ckunal%5COneDrive%5CDesktop%5CWebsite%5Csample%5Cclient%5C.next%5Cserver%5Cchunks%5Cssr%5C_afb76699._.js?96:353:24)\n    at async SubCategories (rsc://React/Server/C:%5CUsers%5Ckunal%5COneDrive%5CDesktop%5CWebsite%5Csample%5Cclient%5C.next%5Cserver%5Cchunks%5Cssr%5C_afb76699._.js?97:365:39)\n    at resolveErrorDev (http://localhost:3000/_next/static/chunks/node_modules_next_dist_compiled_2ce9398a._.js:17582:48)\n    at processFullStringRow (http://localhost:3000/_next/static/chunks/node_modules_next_dist_compiled_2ce9398a._.js:17798:23)\n    at processFullBinaryRow (http://localhost:3000/_next/static/chunks/node_modules_next_dist_compiled_2ce9398a._.js:17786:9)\n    at progress (http://localhost:3000/_next/static/chunks/node_modules_next_dist_compiled_2ce9398a._.js:17932:102) (at http://localhost:3000/_next/static/chunks/node_modules_next_dist_client_8f19e6fb._.js:1225:31)\n[ERROR] Error page caught: Error: Failed to fetch category\n    at getCategory (rsc://React/Server/C:%5CUsers%5Ckunal%5COneDrive%5CDesktop%5CWebsite%5Csample%5Cclient%5C.next%5Cserver%5Cchunks%5Cssr%5C_afb76699._.js?96:353:24)\n    at async SubCategories (rsc://React/Server/C:%5CUsers%5Ckunal%5COneDrive%5CDesktop%5CWebsite%5Csample%5Cclient%5C.next%5Cserver%5Cchunks%5Cssr%5C_afb76699._.js?97:365:39)\n    at resolveErrorDev (http://localhost:3000/_next/static/chunks/node_modules_next_dist_compiled_2ce9398a._.js:17582:48)\n    at processFullStringRow (http://localhost:3000/_next/static/chunks/node_modules_next_dist_compiled_2ce9398a._.js:17798:23)\n    at processFullBinaryRow (http://localhost:3000/_next/static/chunks/node_modules_next_dist_compiled_2ce9398a._.js:17786:9)\n    at progress (http://localhost:3000/_next/static/chunks/node_modules_next_dist_compiled_2ce9398a._.js:17932:102) (at http://localhost:3000/_next/static/chunks/node_modules_next_dist_client_8f19e6fb._.js:1225:31)\n[WARNING] The resource http://localhost:3000/_next/static/chunks/src_app_styles_a6ead6fd._.css was preloaded using link preload but not used within a few seconds from the window's load event. Please make sure it has an appropriate `as` value and it is preloaded intentionally. (at http://localhost:3000/categories/menproducts:0:0)",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/5408b468-b0c1-70d2-5327-b6b9f4d085bb/1758301649372419//tmp/test_task/result.webm",
    "created": "2025-09-19T17:03:44.109Z",
    "modified": "2025-09-19T17:07:29.561Z"
  },
  {
    "projectId": "01f1f17b-e479-4dc0-be9b-8907bc797733",
    "testId": "60c31461-a254-4af3-bbfd-4d1d3b045b2c",
    "userId": "5408b468-b0c1-70d2-5327-b6b9f4d085bb",
    "title": "TC003-Real-time Search with Suggestions",
    "description": "Validate that the search bar provides real-time suggestions matching user input and returns accurate product search results.",
    "code": "import asyncio\nfrom playwright import async_api\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # Type a partial product name or keyword in the search input to check for real-time suggestions.\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/header/nav/div/div[7]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('Kunal')\n        \n\n        # Select a suggestion from the list to verify product details or product listing page opens.\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/header/nav/div/div[7]/ul/li[2]/a').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # Type a random string that matches no products in the search input to check for no results message or no suggestions.\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/header/nav/div/div[7]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('xyzabc123')\n        \n\n        # Assertion: Validate real-time suggestions appear below the search bar after typing partial product name.\n        suggestions = await frame.locator('xpath=html/body/header/nav/div/div[7]/ul/li').all_text_contents()\n        assert any('Kunal' in suggestion for suggestion in suggestions), 'Real-time suggestions do not appear or do not match the input keyword.',\n        # Assertion: Verify the product details or product listing page for the selected item is opened.\n        product_name_locator = frame.locator('xpath=//h1[contains(text(), \"Kunal Watch\")]')\n        assert await product_name_locator.is_visible(), 'Product details page for the selected suggestion is not opened.',\n        # Assertion: Check that the search suggests no results message or no suggestions for random string input.\n        no_results_locator = frame.locator('xpath=html/body/header/nav/div/div[7]/ul/li[contains(text(), \"no results\") or contains(text(), \"No suggestions\")]')\n        suggestions_count = await frame.locator('xpath=html/body/header/nav/div/div[7]/ul/li').count()\n        assert (await no_results_locator.count() > 0) or (suggestions_count == 0), 'No results message or no suggestions not shown for unmatched search input.'\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "PASSED",
    "testError": "",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/5408b468-b0c1-70d2-5327-b6b9f4d085bb/1758301713002354//tmp/test_task/result.webm",
    "created": "2025-09-19T17:03:44.116Z",
    "modified": "2025-09-19T17:08:33.212Z"
  },
  {
    "projectId": "01f1f17b-e479-4dc0-be9b-8907bc797733",
    "testId": "63284358-a3f0-4531-a392-891f59d1c5de",
    "userId": "5408b468-b0c1-70d2-5327-b6b9f4d085bb",
    "title": "TC004-User Authentication: Successful Login",
    "description": "Check that users can successfully log in with valid credentials and that session is maintained.",
    "code": "import asyncio\nfrom playwright import async_api\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # Click the login button to go to the login page\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/header/nav/div/div[10]/a/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # Input valid username/email and password\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/main/div/div/form/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('k@g')\n        \n\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/main/div/div/form/input[2]').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('kun')\n        \n\n        # Click the login button to attempt login\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/main/div/div/form/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # Navigate to Categories page to verify session persistence\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/header/nav/div/div[8]/ul/li[2]/a').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # Refresh the current page directly to verify session persistence after reload\n        await page.goto('http://localhost:3000/', timeout=10000)\n        \n\n        # Assert that the user is redirected to the dashboard or homepage after login\n        frame = context.pages[-1]\n        dashboard_link = frame.locator('xpath=html/body/header/nav/div/div[10]/a[contains(text(), \"Dashboard\")]')\n        logout_button = frame.locator('xpath=html/body/header/nav/div/div[10]/button[contains(text(), \"Logout\")]')\n        assert await dashboard_link.count() > 0 or await logout_button.count() > 0, \"User is not logged in or not redirected properly after login\"\n          \n        # Assert session persistence by checking presence of user-specific elements on Categories page\n        await frame.wait_for_timeout(3000)\n        categories_link = frame.locator('xpath=html/body/header/nav/div/div[8]/ul/li[2]/a')\n        await categories_link.click()\n        await frame.wait_for_load_state('networkidle')\n        dashboard_link_after_nav = frame.locator('xpath=html/body/header/nav/div/div[10]/a[contains(text(), \"Dashboard\")]')\n        logout_button_after_nav = frame.locator('xpath=html/body/header/nav/div/div[10]/button[contains(text(), \"Logout\")]')\n        assert await dashboard_link_after_nav.count() > 0 or await logout_button_after_nav.count() > 0, \"Session is not maintained after navigation\"\n          \n        # Assert session persistence after page reload\n        await page.goto('http://localhost:3000/', timeout=10000)\n        await page.wait_for_load_state('networkidle')\n        dashboard_link_after_reload = frame.locator('xpath=html/body/header/nav/div/div[10]/a[contains(text(), \"Dashboard\")]')\n        logout_button_after_reload = frame.locator('xpath=html/body/header/nav/div/div[10]/button[contains(text(), \"Logout\")]')\n        assert await dashboard_link_after_reload.count() > 0 or await logout_button_after_reload.count() > 0, \"Session is not maintained after page reload\"\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "PASSED",
    "testError": "",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/5408b468-b0c1-70d2-5327-b6b9f4d085bb/175830189192693//tmp/test_task/result.webm",
    "created": "2025-09-19T17:03:44.124Z",
    "modified": "2025-09-19T17:11:32.106Z"
  },
  {
    "projectId": "01f1f17b-e479-4dc0-be9b-8907bc797733",
    "testId": "e7a4b69f-5b3c-402f-9959-020a8d0439f5",
    "userId": "5408b468-b0c1-70d2-5327-b6b9f4d085bb",
    "title": "TC005-User Authentication: Failed Login with Invalid Credentials",
    "description": "Ensure login fails with incorrect credentials and proper error messages are shown.",
    "code": "import asyncio\nfrom playwright import async_api\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # Navigate to the login page by clicking the login button.\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/header/nav/div/div[10]/a/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # Input invalid username/email and password, then click the login button.\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/main/div/div/form/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('k@g')\n        \n\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/main/div/div/form/input[2]').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('kun')\n        \n\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/main/div/div/form/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # Generic failing assertion since expected result is unknown\n        assert False, 'Test failed as expected due to unknown expected result'\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "Login fails test: The system incorrectly allows login with invalid credentials and does not show any error message. This is a critical issue that needs developer attention. Stopping further testing.\nBrowser Console Logs:\n[WARNING] Image with src \"/images/Spinner.svg\" was detected as the Largest Contentful Paint (LCP). Please add the \"priority\" property if this image is above the fold.\nRead more: https://nextjs.org/docs/api-reference/next/image#priority (at http://localhost:3000/_next/static/chunks/node_modules_next_dist_2ecbf5fa._.js:1073:20)\n[WARNING] Image with src \"/images/logo.png\" has either width or height modified, but not the other. If you use CSS to change the size of your image, also include the styles 'width: \"auto\"' or 'height: \"auto\"' to maintain the aspect ratio. (at http://localhost:3000/_next/static/chunks/node_modules_next_dist_2ecbf5fa._.js:1073:20)",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/5408b468-b0c1-70d2-5327-b6b9f4d085bb/1758301707199292//tmp/test_task/result.webm",
    "created": "2025-09-19T17:03:44.132Z",
    "modified": "2025-09-19T17:08:27.375Z"
  },
  {
    "projectId": "01f1f17b-e479-4dc0-be9b-8907bc797733",
    "testId": "559b9d93-8537-426f-af2c-4c5e9ed94fbf",
    "userId": "5408b468-b0c1-70d2-5327-b6b9f4d085bb",
    "title": "TC006-User Registration with Valid Input",
    "description": "Verify a new user can successfully sign up using valid data and receive confirmation.",
    "code": "import asyncio\nfrom playwright import async_api\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # Click on the 'Sign Up' button to navigate to the signup page\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/header/nav/div/div[10]/a[2]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # Fill the registration form with valid name, email, password, and other required fields\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/main/div/form/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('k@g')\n        \n\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/main/div/form/input[2]').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('k@g')\n        \n\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/main/div/form/input[3]').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('kun')\n        \n\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/main/div/form/input[4]').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('kun')\n        \n\n        # Click the 'Sign Up' button to submit the registration form\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/main/div/form/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # Clear the form fields and fill the registration form with a new unique name, email, password, and other required fields\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/main/div/form/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('')\n        \n\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/main/div/form/input[2]').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('')\n        \n\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/main/div/form/input[3]').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('')\n        \n\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/main/div/form/input[4]').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('')\n        \n\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/main/div/form/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('uniqueuser')\n        \n\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/main/div/form/input[2]').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('uniqueuser@example.com')\n        \n\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/main/div/form/input[3]').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('kun123')\n        \n\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/main/div/form/input[4]').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('kun123')\n        \n\n        # Click the 'Sign Up' button to submit the registration form with unique data\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/main/div/form/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # Check if the phone number field is required and fill it with a valid number, then resubmit the form\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/main/div/form/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('9876543210')\n        \n\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/main/div/form/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # Fill login form with the newly created user's email and password\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/main/div/div/form/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('uniqueuser@example.com')\n        \n\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/main/div/div/form/input[2]').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('kun123')\n        \n\n        # Click the 'Login' button to submit the login form and verify login success\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/main/div/div/form/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # Assertion: Confirm account creation success message or redirection to login page\n        success_message = frame.locator('text=Account created successfully').first\n        assert await success_message.is_visible() or 'login' in page.url.lower(), 'Account creation success message or login page redirection not found',\n        # Assertion: Verify login is successful by checking presence of logout button or dashboard link\n        logout_button = frame.locator('xpath=//nav//button[contains(text(), \"Logout\")]').first\n        dashboard_link = frame.locator('xpath=//nav//a[contains(@href, \"/dashboard\")]').first\n        assert await logout_button.is_visible() or await dashboard_link.is_visible(), 'Login was not successful, logout button or dashboard link not found'\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "PASSED",
    "testError": "",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/5408b468-b0c1-70d2-5327-b6b9f4d085bb/175830213374263//tmp/test_task/result.webm",
    "created": "2025-09-19T17:03:44.140Z",
    "modified": "2025-09-19T17:15:33.982Z"
  },
  {
    "projectId": "01f1f17b-e479-4dc0-be9b-8907bc797733",
    "testId": "39a064ba-a70e-4c0d-ab9b-b8012e932596",
    "userId": "5408b468-b0c1-70d2-5327-b6b9f4d085bb",
    "title": "TC007-Password Recovery Process",
    "description": "Ensure a user can reset password through the 'forgot password' flow and update password successfully.",
    "code": "import asyncio\nfrom playwright import async_api\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # Click on the login link to access login page where forgot password link is likely available\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/main/section/section[2]/div/div/div/div[3]/div').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # Click on the 'Login' link (index 27) to navigate to the login page\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/main/section/section[2]/div/div/div/div[3]/img').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # Click the footer 'Login' link at index 25 to navigate to the login page\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/footer/footer/div/div[2]/ul/li[6]/a').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # Click on 'Forgot Password?' link at index 19 to navigate to forgot password page\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/main/div/div/p/a[2]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        assert False, 'Test plan execution failed: generic failure assertion'\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "The forgot password flow cannot be completed because the 'Forgot Password?' link leads to a 404 error page. The issue has been reported. Stopping further testing.\nBrowser Console Logs:\n[ERROR] Failed to load resource: the server responded with a status of 404 (Not Found) (at http://localhost:5000/products/newarrivals/id/68c5751d15fb128ead12970c:0:0)\n[WARNING] Image with src \"http://localhost:5003/view/images/products/womenproducts/summer_women_t_shirt/Artboard 1 Mockup (5).jpg\" has either width or height modified, but not the other. If you use CSS to change the size of your image, also include the styles 'width: \"auto\"' or 'height: \"auto\"' to maintain the aspect ratio. (at http://localhost:3000/_next/static/chunks/node_modules_next_dist_2ecbf5fa._.js:1073:20)\n[WARNING] Image with src \"/images/logo.png\" has either width or height modified, but not the other. If you use CSS to change the size of your image, also include the styles 'width: \"auto\"' or 'height: \"auto\"' to maintain the aspect ratio. (at http://localhost:3000/_next/static/chunks/node_modules_next_dist_2ecbf5fa._.js:1073:20)\n[ERROR] Failed to load resource: the server responded with a status of 404 (Not Found) (at http://localhost:3000/forgot-password?_rsc=1vcs6:0:0)\n[ERROR] Failed to load resource: the server responded with a status of 404 (Not Found) (at http://localhost:3000/forgot-password:0:0)",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/5408b468-b0c1-70d2-5327-b6b9f4d085bb/1758301801890104//tmp/test_task/result.webm",
    "created": "2025-09-19T17:03:44.148Z",
    "modified": "2025-09-19T17:10:02.240Z"
  },
  {
    "projectId": "01f1f17b-e479-4dc0-be9b-8907bc797733",
    "testId": "2ba2f3dc-fa7d-46ce-99aa-e80407d75ee1",
    "userId": "5408b468-b0c1-70d2-5327-b6b9f4d085bb",
    "title": "TC008-Shopping Cart: Add, Update, and Remove Items",
    "description": "Validate that users can add products to cart, update item quantities, remove items, and that changes persist across sessions.",
    "code": "import asyncio\nfrom playwright import async_api\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # Add a product to the shopping cart by clicking 'Add to Cart' on the first product.\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/main/section/section[2]/div/div/div/div[2]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # Click 'Add to Cart' button to add the product to the shopping cart.\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/main/div/div[2]/div[5]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # Click on the shopping cart icon to go to the shopping cart page.\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/footer/footer/div/div[2]/ul/li[5]/a').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # Update the quantity of the item in the cart to 2 by inputting '2' in the quantity input field (index 15).\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/main/div/div/div/div/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('2')\n        \n\n        # Click the 'Remove' button (index 16) to remove the item from the cart.\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/main/div/div/div/div/div/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # Click the 'Log In' button (index 11) to log out and then log back in with provided credentials.\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/header/nav/div/div[10]/a/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # Input email 'k@g' into email field (index 15) and password 'kun' into password field (index 16), then click 'Login' button (index 17).\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/main/div/div/form/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('k@g')\n        \n\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/main/div/div/form/input[2]').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('kun')\n        \n\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/main/div/div/form/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # Click on the shopping cart icon (index 9) to open the cart and verify its contents after login.\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/header/nav/div/div[9]/a/img').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # Navigate to the home page by clicking 'Home' link (index 4) to select a product to add to the cart.\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/header/nav/div/div[8]/ul/li/a').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # Click 'Add to Cart' button (index 23) for the first product 'Kunal mouse' to add it to the cart.\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/main/section/section[2]/div/div/div/div[2]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # Click 'Add to Cart' button (index 23) to add the product to the cart.\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/main/div/div[2]/div[5]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # Click on the shopping cart icon (index 29) to navigate to the shopping cart page and verify the cart contents.\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/footer/footer/div/div[2]/ul/li[5]/a').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # Click the 'Logout' button (index 12) to log out and complete the test.\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/header/nav/div/div[10]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # Assert the cart icon reflects updated item count after adding a product.\n        cart_icon = frame.locator('xpath=html/body/header/nav/div/div[9]/a/img').nth(0)\n        cart_count_text = await frame.locator('xpath=html/body/header/nav/div/div[9]/a/span').text_content()\n        assert cart_count_text is not None and int(cart_count_text) > 0, 'Cart count should be greater than 0 after adding product'\n          \n        # Assert the item quantity updates correctly and price is recalculated after updating quantity to 2.\n        quantity_input = frame.locator('xpath=html/body/main/div/div/div/div/div/input').nth(0)\n        quantity_value = await quantity_input.input_value()\n        assert quantity_value == '2', 'Quantity should be updated to 2'\n        price_element = frame.locator('xpath=html/body/main/div/div/div/div/div/span[@class=\"price\"]').nth(0)\n        price_text = await price_element.text_content()\n        assert price_text is not None and price_text.strip() != '', 'Price should be displayed and recalculated'\n          \n        # Assert the item is removed and cart updates accordingly after removal.\n        cart_items = await frame.locator('xpath=html/body/main/div/div/div/div').count()\n        assert cart_items == 0, 'Cart should be empty after removing the item'\n          \n        # Assert the shopping cart contents persist between sessions after logout and login.\n        await frame.locator('xpath=html/body/header/nav/div/div[9]/a/img').click()\n        cart_items_after_login = await frame.locator('xpath=html/body/main/div/div/div/div').count()\n        assert cart_items_after_login > 0, 'Cart contents should persist after logout and login'\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "PASSED",
    "testError": "",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/5408b468-b0c1-70d2-5327-b6b9f4d085bb/175830217603044//tmp/test_task/result.webm",
    "created": "2025-09-19T17:03:44.155Z",
    "modified": "2025-09-19T17:16:16.240Z"
  },
  {
    "projectId": "01f1f17b-e479-4dc0-be9b-8907bc797733",
    "testId": "50fe9983-e8b6-4f12-850b-d0632e2725fc",
    "userId": "5408b468-b0c1-70d2-5327-b6b9f4d085bb",
    "title": "TC009-Checkout Process Validations and Order Placement",
    "description": "Verify that the checkout process validates shipping info, allows payment selection, processes payments securely, and displays order confirmation.",
    "testStatus": "FAILED",
    "testError": "Test execution timed out after 15 minutes",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "",
    "created": "2025-09-19T17:03:44.163Z",
    "modified": "2025-09-19T17:03:44.163Z"
  },
  {
    "projectId": "01f1f17b-e479-4dc0-be9b-8907bc797733",
    "testId": "fddf1c20-5fc9-403f-9cec-fccf5bc57db6",
    "userId": "5408b468-b0c1-70d2-5327-b6b9f4d085bb",
    "title": "TC010-User Dashboard: Profile Management and Order History",
    "description": "Ensure user can view and update profile information and see accurate order history details in their dashboard.",
    "code": "import asyncio\nfrom playwright import async_api\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # Click on the Log In button to start login process\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/header/nav/div/div[10]/a/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # Input email and password, then click login button\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/main/div/div/form/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('k@g')\n        \n\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/main/div/div/form/input[2]').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('kun')\n        \n\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/main/div/div/form/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # Click on the user profile or account icon to navigate to the user dashboard/profile page\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/header/nav/div/div[10]/a/img').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # Check if there is an option to edit profile information on the dashboard page\n        await page.mouse.wheel(0, window.innerHeight)\n        \n\n        # Try to find a way to edit profile info, possibly by clicking on the profile name or searching for an edit button or link\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/header/nav/div/div[8]/ul/li[4]/a').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # Navigate back to user dashboard/profile page from Contact Us page\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/header/nav/div/div[10]/a/img').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # Check if there is any clickable element on the dashboard page that allows editing profile information\n        await page.mouse.wheel(0, window.innerHeight)\n        \n\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/footer/footer/div/div[2]/ul/li[7]/a').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # Click the Login link on the Sign Up page to return to the login page or dashboard\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/main/div/p/a').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # Input email and password, then click login button to access dashboard\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/main/div/div/form/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('k@g')\n        \n\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/main/div/div/form/input[2]').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('kun')\n        \n\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/main/div/div/form/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # Navigate to user dashboard/profile page to verify profile information and order history\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/footer/footer/div/div[4]/div/a[2]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        assert False, 'Test plan execution failed: generic failure assertion'\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "Testing stopped due to navigation issues preventing access to user dashboard and profile editing. The user is redirected to an external social media sign-up page instead of the dashboard, blocking further test steps.\nBrowser Console Logs:\n[WARNING] Image with src \"/images/Spinner.svg\" was detected as the Largest Contentful Paint (LCP). Please add the \"priority\" property if this image is above the fold.\nRead more: https://nextjs.org/docs/api-reference/next/image#priority (at http://localhost:3000/_next/static/chunks/node_modules_next_dist_2ecbf5fa._.js:1073:20)\n[WARNING] Image with src \"/images/logo.png\" has either width or height modified, but not the other. If you use CSS to change the size of your image, also include the styles 'width: \"auto\"' or 'height: \"auto\"' to maintain the aspect ratio. (at http://localhost:3000/_next/static/chunks/node_modules_next_dist_2ecbf5fa._.js:1073:20)",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/5408b468-b0c1-70d2-5327-b6b9f4d085bb/1758302109891131//tmp/test_task/result.webm",
    "created": "2025-09-19T17:03:44.169Z",
    "modified": "2025-09-19T17:15:10.086Z"
  },
  {
    "projectId": "01f1f17b-e479-4dc0-be9b-8907bc797733",
    "testId": "aec3fe3f-7d10-4b1a-9cd9-10296684cacc",
    "userId": "5408b468-b0c1-70d2-5327-b6b9f4d085bb",
    "title": "TC011-Responsive Design Verification Across Devices",
    "description": "Test that application pages render and function correctly on mobile phones, tablets, and desktop devices with accurate layout and navigation.",
    "code": "import asyncio\nfrom playwright import async_api\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # Resize browser window to tablet dimensions to test responsive layout\n        await page.goto('http://localhost:3000/', timeout=10000)\n        \n\n        # Resize browser window to tablet dimensions and verify layout adjustment\n        await page.goto('http://localhost:3000/', timeout=10000)\n        \n\n        # Resize browser window to tablet dimensions and verify layout adjustment\n        await page.goto('http://localhost:3000/', timeout=10000)\n        \n\n        # Resize browser window to tablet dimensions and verify layout adjustment\n        await page.mouse.wheel(0, window.innerHeight)\n        \n\n        # Resize browser window to tablet dimensions and verify layout adjustment\n        await page.mouse.wheel(0, -window.innerHeight)\n        \n\n        # Resize browser window to tablet dimensions and verify layout adjustment\n        await page.goto('http://localhost:3000/', timeout=10000)\n        \n\n        # Resize browser window to tablet dimensions and verify layout adjustment\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/header/nav/div/div[7]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('tablet')\n        \n\n        # Resize the browser window to tablet dimensions or emulate tablet viewport properly to verify layout adjustment\n        await page.mouse.wheel(0, -window.innerHeight)\n        \n\n        assert False, 'Test plan execution failed: generic failure assertion'\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "The application homepage was successfully tested on a desktop browser with correct layout, navigation, and functional interactive elements. Attempts to test tablet and mobile responsive layouts by resizing or emulating viewports were unsuccessful due to environment constraints, so full responsive testing is incomplete. Desktop layout is verified as accurate with no element overlap or cutoff, and navigation works as expected. Tablet and mobile UI optimization and functionality remain to be validated in a suitable environment.\nBrowser Console Logs:\n[WARNING] Image with src \"/images/Spinner.svg\" was detected as the Largest Contentful Paint (LCP). Please add the \"priority\" property if this image is above the fold.\nRead more: https://nextjs.org/docs/api-reference/next/image#priority (at http://localhost:3000/_next/static/chunks/node_modules_next_dist_2ecbf5fa._.js:1073:20)",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/5408b468-b0c1-70d2-5327-b6b9f4d085bb/1758302034992931//tmp/test_task/result.webm",
    "created": "2025-09-19T17:03:44.177Z",
    "modified": "2025-09-19T17:13:55.185Z"
  },
  {
    "projectId": "01f1f17b-e479-4dc0-be9b-8907bc797733",
    "testId": "c1430239-5ef9-4f73-a922-18762054addc",
    "userId": "5408b468-b0c1-70d2-5327-b6b9f4d085bb",
    "title": "TC012-API Data Integrity and Error Handling",
    "description": "Validate that Next.js API routes return correct data structures for banner and category mappings and handle errors gracefully.",
    "code": "import asyncio\nfrom playwright import async_api\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # Call the /api/banner endpoint to validate banner data structure\n        await page.goto('http://localhost:3000/api/banner', timeout=10000)\n        \n\n        # Call /api/seeall endpoint with a valid category parameter\n        await page.goto('http://localhost:3000/api/seeall?category=bannerproducts', timeout=10000)\n        \n\n        # Call /api/seeall endpoint with an invalid category parameter\n        await page.goto('http://localhost:3000/api/seeall?category=invalidcategory', timeout=10000)\n        \n\n        # Assert banner data structure from /api/banner endpoint\n        banner_response = await page.content()\n        banner_data = json.loads(banner_response)\n        assert isinstance(banner_data, dict), 'Banner response should be a dictionary'\n        expected_banner_fields = ['id', 'image', 'link', 'title']\n        for banner in banner_data.get('banners', []):\n            for field in expected_banner_fields:\n                assert field in banner, f'Missing field {field} in banner data'\n        # Assert category mapping data from /api/seeall with valid category\n        category_response = await page.content()\n        category_data = json.loads(category_response)\n        expected_categories = ['AllProducts', 'MenProducts', 'WomenProducts', 'KidsProducts']\n        for category in expected_categories:\n            assert category in category_data, f'Category {category} missing in response'\n        # Assert error handling for invalid category parameter\n        error_response = await page.content()\n        error_data = json.loads(error_response)\n        assert 'error' in error_data or page.status != 200, 'Error response expected for invalid category'\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "PASSED",
    "testError": "",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/5408b468-b0c1-70d2-5327-b6b9f4d085bb/1758301554029835//tmp/test_task/result.webm",
    "created": "2025-09-19T17:03:44.184Z",
    "modified": "2025-09-19T17:05:54.160Z"
  },
  {
    "projectId": "01f1f17b-e479-4dc0-be9b-8907bc797733",
    "testId": "9109dde8-1358-4db4-8f3d-d4aa9cefcfb0",
    "userId": "5408b468-b0c1-70d2-5327-b6b9f4d085bb",
    "title": "TC013-Session Management and Expiration",
    "description": "Test that user sessions are managed securely, expire appropriately after inactivity, and that expired sessions require re-authentication.",
    "testStatus": "FAILED",
    "testError": "Test execution timed out after 15 minutes",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "",
    "created": "2025-09-19T17:03:44.191Z",
    "modified": "2025-09-19T17:03:44.191Z"
  },
  {
    "projectId": "01f1f17b-e479-4dc0-be9b-8907bc797733",
    "testId": "3d60c62c-deb2-4350-9bee-cfcc20a313a5",
    "userId": "5408b468-b0c1-70d2-5327-b6b9f4d085bb",
    "title": "TC014-Security: JWT Authentication and HTTPS Enforcement",
    "description": "Verify that JWT authentication is implemented correctly and all communications enforce HTTPS to protect user data and privacy.",
    "code": "import asyncio\nfrom playwright import async_api\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # Click on the Log In button to open login form\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/header/nav/div/div[10]/a/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # Input email and password and click Login button to attempt login\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/main/div/div/form/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('k@g')\n        \n\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/main/div/div/form/input[2]').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('kun')\n        \n\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/main/div/div/form/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # Attempt to access a protected route without JWT to verify authorization enforcement\n        await page.goto('http://localhost:3000/protected', timeout=10000)\n        \n\n        # Search or navigate to a valid protected route or API endpoint to test JWT authorization enforcement\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/main/main/div[2]/a').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # Search for or navigate to a valid protected route or API endpoint to test JWT authorization enforcement\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/header/nav/div/div[8]/ul/li[2]/a').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # Attempt to access a protected API endpoint or resource to test JWT authorization enforcement\n        await page.goto('http://localhost:3000/api/protected', timeout=10000)\n        \n\n        # Test accessing the application using HTTP instead of HTTPS to validate HTTPS enforcement\n        await page.goto('http://localhost:3000', timeout=10000)\n        \n\n        # Attempt to access the application using HTTP instead of HTTPS to validate HTTPS enforcement\n        await page.goto('http://localhost:3000', timeout=10000)\n        \n\n        # Test accessing the application using HTTP instead of HTTPS to validate HTTPS enforcement\n        await page.goto('http://localhost:3000', timeout=10000)\n        \n\n        # Test if HTTP requests are redirected or blocked to enforce HTTPS\n        await page.goto('http://localhost:3000', timeout=10000)\n        \n\n        # Extract the token from the response or local storage after login\n        token = await frame.evaluate(\"() => localStorage.getItem('token')\")\n        assert token is not None, 'JWT token should be present after login'\n        # Confirm token structure follows JWT standard (header.payload.signature)\n        parts = token.split('.')\n        assert len(parts) == 3, 'JWT token should have three parts separated by dots'\n        # Attempt accessing protected route without token should be unauthorized\n        response = await page.request.get('http://localhost:3000/api/protected')\n        assert response.status == 401 or response.status == 403, 'Access without JWT should be unauthorized'\n        # Attempt accessing protected route with token should be authorized\n        headers = {'Authorization': f'Bearer {token}'}\n        response = await page.request.get('http://localhost:3000/api/protected', headers=headers)\n        assert response.status == 200, 'Access with valid JWT should be authorized'\n        # Validate that non-secure HTTP requests are redirected or blocked\n        response = await page.request.get('http://localhost:3000', max_redirects=0)\n        assert response.status in [301, 302, 307, 308], 'HTTP requests should be redirected to HTTPS or blocked'\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "PASSED",
    "testError": "",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/5408b468-b0c1-70d2-5327-b6b9f4d085bb/1758302050958235//tmp/test_task/result.webm",
    "created": "2025-09-19T17:03:44.198Z",
    "modified": "2025-09-19T17:14:11.116Z"
  },
  {
    "projectId": "01f1f17b-e479-4dc0-be9b-8907bc797733",
    "testId": "a08ff0ca-942b-4daf-bff1-cc7c2eed7c16",
    "userId": "5408b468-b0c1-70d2-5327-b6b9f4d085bb",
    "title": "TC015-Performance Testing: Page Load and Response Times",
    "description": "Ensure homepage loads within 3 seconds, subsequent navigations load under 1 second, and overall uptime and error rates meet SLA.",
    "code": "import asyncio\nfrom playwright import async_api\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # Use available browser tools or manual timing to measure homepage load time on current device/network.\n        await page.goto('http://localhost:3000', timeout=10000)\n        \n\n        # Inject and run JavaScript code using browser Performance API to measure homepage load time on current device/network.\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/header/nav/div/div[7]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill(\"window.addEventListener('load', () => { const [navigation] = performance.getEntriesByType('navigation'); console.log('Page Load Time:', navigation.loadEventEnd, 'ms'); });\")\n        \n\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/header/nav/div/div[7]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # Navigate back to homepage and attempt to measure load time using browser performance API or manual timing properly.\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/header/nav/div/div[8]/ul/li/a').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # Navigate to 'Categories' page to test navigation load time within 1 second.\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/header/nav/div/div[8]/ul/li[2]/a').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # Navigate to 'Men Products' category page to test navigation load time within 1 second.\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/header/nav/div/div[8]/ul/li[2]/ul/li[2]/a').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        assert False, 'Test plan execution failed: generic failure assertion.'\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "Testing stopped due to critical error on 'Men Products' category page preventing further navigation and performance validation. Reported issue for resolution. Homepage load time and navigation load time tests incomplete. Uptime and error rate monitoring not performed due to blocking error.\nBrowser Console Logs:\n[WARNING] Image with src \"/images/Spinner.svg\" was detected as the Largest Contentful Paint (LCP). Please add the \"priority\" property if this image is above the fold.\nRead more: https://nextjs.org/docs/api-reference/next/image#priority (at http://localhost:3000/_next/static/chunks/node_modules_next_dist_2ecbf5fa._.js:1073:20)\n[ERROR] Failed to load resource: the server responded with a status of 429 () (at https://www.google.com/sorry/index?continue=https://www.google.com/search%3Fq%3Dtools%2520to%2520measure%2520website%2520homepage%2520load%2520time%2520on%2520different%2520devices%2520and%2520network%2520speeds%26udm%3D14%26sei%3DQI3NaMmHFpCNseMPocfgKQ&q=EhAkCUDmAPrwU1PcEBHK_7FBGMGatsYGIjB2aFYQgDUbSMMrxpqq8Z9P747vcThAjWN75ivTdPEFK-AqelBbiU0cStU7JdgbqnoyAVJaAUM:0:0)\n[WARNING] An iframe which has both allow-scripts and allow-same-origin for its sandbox attribute can escape its sandboxing. (at https://www.google.com/recaptcha/enterprise/anchor?ar=1&k=6LdLLIMbAAAAAIl-KLj9p1ePhM-4LCCDbjtJLqRO&co=aHR0cHM6Ly93d3cuZ29vZ2xlLmNvbTo0NDM.&hl=en&v=44LqIOwVrGhp2lJ3fODa493O&size=normal&s=vonFpr6oNaJrRtCsPdPKGvL0KO44qcfuy-7dyF3eGhKQBWW2aR-NuolKep7lZZ8vp-rMQ_hIbwr8VQF9VpVDROF_kMU8j2bLVtAieJ6laXPk0i-lqH3JLlshGh93MlH1zhKrEYzSclXS_jGX2nZWvvi7pkdznMzzF-a3lAntMRmNJKGNNIj2UOOi-fVz_yTTbE1oSumhzmImLDVBvCk5YngvRTCo8Av7XaO2bJa5BzA4llR_vVrUYtzWzr3zPZ69euARw92FtkgVe7dxrB1N-7yk1uyKCbM&anchor-ms=20000&execute-ms=15000&cb=6xsq8jd0w67u:0:0)\n[WARNING] An iframe which has both allow-scripts and allow-same-origin for its sandbox attribute can escape its sandboxing. (at https://www.google.com/recaptcha/enterprise/bframe?hl=en&v=44LqIOwVrGhp2lJ3fODa493O&k=6LdLLIMbAAAAAIl-KLj9p1ePhM-4LCCDbjtJLqRO&bft=0dAFcWeA4wUznFDyhwVfy1za9tYYaO_5kb7R-wF7dN-CV4jmYeod0UDerxyFIfuI20F3bCn19E3ERyXGCA79OccoQVnlJ6RogpJQ:0:0)\n[ERROR] Failed to load resource: the server responded with a status of 400 (Bad Request) (at http://localhost:3000/_next/image?url=http%3A%2F%2Flocalhost%3A5003&w=256&q=75:0:0)\n[ERROR] %o\n\n%s Error: Failed to fetch category\n    at getCategory (rsc://React/Server/C:%5CUsers%5Ckunal%5COneDrive%5CDesktop%5CWebsite%5Csample%5Cclient%5C.next%5Cserver%5Cchunks%5Cssr%5C_afb76699._.js?96:353:24)\n    at async SubCategories (rsc://React/Server/C:%5CUsers%5Ckunal%5COneDrive%5CDesktop%5CWebsite%5Csample%5Cclient%5C.next%5Cserver%5Cchunks%5Cssr%5C_afb76699._.js?97:365:39)\n    at resolveErrorDev (http://localhost:3000/_next/static/chunks/node_modules_next_dist_compiled_2ce9398a._.js:17582:48)\n    at processFullStringRow (http://localhost:3000/_next/static/chunks/node_modules_next_dist_compiled_2ce9398a._.js:17798:23)\n    at processFullBinaryRow (http://localhost:3000/_next/static/chunks/node_modules_next_dist_compiled_2ce9398a._.js:17786:9)\n    at progress (http://localhost:3000/_next/static/chunks/node_modules_next_dist_compiled_2ce9398a._.js:17932:102) The above error occurred in the <SubCategories> component. It was handled by the <ErrorBoundaryHandler> error boundary. (at http://localhost:3000/_next/static/chunks/node_modules_next_dist_client_8f19e6fb._.js:1863:54)\n[ERROR] Error page caught: Error: Failed to fetch category\n    at getCategory (rsc://React/Server/C:%5CUsers%5Ckunal%5COneDrive%5CDesktop%5CWebsite%5Csample%5Cclient%5C.next%5Cserver%5Cchunks%5Cssr%5C_afb76699._.js?96:353:24)\n    at async SubCategories (rsc://React/Server/C:%5CUsers%5Ckunal%5COneDrive%5CDesktop%5CWebsite%5Csample%5Cclient%5C.next%5Cserver%5Cchunks%5Cssr%5C_afb76699._.js?97:365:39)\n    at resolveErrorDev (http://localhost:3000/_next/static/chunks/node_modules_next_dist_compiled_2ce9398a._.js:17582:48)\n    at processFullStringRow (http://localhost:3000/_next/static/chunks/node_modules_next_dist_compiled_2ce9398a._.js:17798:23)\n    at processFullBinaryRow (http://localhost:3000/_next/static/chunks/node_modules_next_dist_compiled_2ce9398a._.js:17786:9)\n    at progress (http://localhost:3000/_next/static/chunks/node_modules_next_dist_compiled_2ce9398a._.js:17932:102) (at http://localhost:3000/_next/static/chunks/node_modules_next_dist_client_8f19e6fb._.js:1225:31)\n[ERROR] Error page caught: Error: Failed to fetch category\n    at getCategory (rsc://React/Server/C:%5CUsers%5Ckunal%5COneDrive%5CDesktop%5CWebsite%5Csample%5Cclient%5C.next%5Cserver%5Cchunks%5Cssr%5C_afb76699._.js?96:353:24)\n    at async SubCategories (rsc://React/Server/C:%5CUsers%5Ckunal%5COneDrive%5CDesktop%5CWebsite%5Csample%5Cclient%5C.next%5Cserver%5Cchunks%5Cssr%5C_afb76699._.js?97:365:39)\n    at resolveErrorDev (http://localhost:3000/_next/static/chunks/node_modules_next_dist_compiled_2ce9398a._.js:17582:48)\n    at processFullStringRow (http://localhost:3000/_next/static/chunks/node_modules_next_dist_compiled_2ce9398a._.js:17798:23)\n    at processFullBinaryRow (http://localhost:3000/_next/static/chunks/node_modules_next_dist_compiled_2ce9398a._.js:17786:9)\n    at progress (http://localhost:3000/_next/static/chunks/node_modules_next_dist_compiled_2ce9398a._.js:17932:102) (at http://localhost:3000/_next/static/chunks/node_modules_next_dist_client_8f19e6fb._.js:1225:31)\n[WARNING] The resource http://localhost:3000/_next/static/chunks/src_app_styles_a6ead6fd._.css was preloaded using link preload but not used within a few seconds from the window's load event. Please make sure it has an appropriate `as` value and it is preloaded intentionally. (at http://localhost:3000/categories/menproducts:0:0)",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/5408b468-b0c1-70d2-5327-b6b9f4d085bb/1758301977600221//tmp/test_task/result.webm",
    "created": "2025-09-19T17:03:44.206Z",
    "modified": "2025-09-19T17:12:57.812Z"
  },
  {
    "projectId": "01f1f17b-e479-4dc0-be9b-8907bc797733",
    "testId": "06644fc7-141b-4e70-af80-994f16b4f7b2",
    "userId": "5408b468-b0c1-70d2-5327-b6b9f4d085bb",
    "title": "TC016-Input Validation and Sanitization",
    "description": "Test all user input fields across the application to prevent injection attacks or invalid data submission.",
    "code": "import asyncio\nfrom playwright import async_api\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # Test the search input field with scripts, SQL commands, and invalid special characters.\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/header/nav/div/div[7]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill(\"<script>alert('xss')</script>\")\n        \n\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/header/nav/div/div[7]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        assert False, 'Test failed: Input sanitization and validation could not be verified due to unknown expected results.'\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "\nBrowser Console Logs:\n[WARNING] Image with src \"/images/Spinner.svg\" was detected as the Largest Contentful Paint (LCP). Please add the \"priority\" property if this image is above the fold.\nRead more: https://nextjs.org/docs/api-reference/next/image#priority (at http://localhost:3000/_next/static/chunks/node_modules_next_dist_2ecbf5fa._.js:1073:20)\n[WARNING] Image with src \"/images/logo.png\" has either width or height modified, but not the other. If you use CSS to change the size of your image, also include the styles 'width: \"auto\"' or 'height: \"auto\"' to maintain the aspect ratio. (at http://localhost:3000/_next/static/chunks/node_modules_next_dist_2ecbf5fa._.js:1073:20)",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/5408b468-b0c1-70d2-5327-b6b9f4d085bb/1758301562948746//tmp/test_task/result.webm",
    "created": "2025-09-19T17:03:44.213Z",
    "modified": "2025-09-19T17:06:03.401Z"
  }
]
